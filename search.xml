<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode 刷题记录-56.Merge Intervals]]></title>
    <url>%2F2019%2F02%2F22%2Fleetcode%20%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-56.Merge%20Intervals%2F</url>
    <content type="text"><![CDATA[题目Given a collection of intervals, merge all overlapping intervals. Example 1: 123Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: 123Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. 说明给定一组表示区间的列表，把其中所有有重叠的区间合并，输出新的一组区间列表 分析解题思路首先对输入的列表按照start值由小到大排序。然后取已排序列表的第一个区间的end和下一个区间的start对比，如果有重叠，则更新区间的end为这两个区间的end中较大的一个；如果没有重叠，则把更新后的区间增加到返回列表中。然后继续与已排序列表中的下一个对比，直到列表的末尾。 复杂度分析排序的时间复杂度为O(nlogn), 列表逐元素对比的时间复杂度为O(n)，所以总体的时间复杂度为O(nlogn)。 代码123456789101112131415161718192021222324252627282930/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if(intervals.size() &lt;= 1) return intervals; intervals.sort((i1, i2) -&gt; Integer.compare(i1.start, i2.start)); List&lt;Interval&gt; result = new LinkedList&lt;Interval&gt;(); int start = intervals.get(0).start; int end = intervals.get(0).end; for(Interval interval : intervals)&#123; if(interval.start &lt;= end)&#123; end = Math.max(interval.end, end); &#125;else&#123; result.add(new Interval(start, end)); start = interval.start; end = interval.end; &#125; &#125; result.add(new Interval(start, end)); return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MobileFaceNets论文阅读笔记]]></title>
    <url>%2F2018%2F05%2F02%2FMobileFaceNets%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[论文链接：MobileFaceNets: Efficient CNNs for Accurate Real-Time Face Verification on Mobile Devices 核心改进点用 MobileNetV1, ShuffleNet, MobileNetV2等网络做人脸识别时，在embedding层之前往往采用global average pooling得到特征，但其他论文已经提出使用global average pooling后的CNN效果会比不使用global average pooling差，本文从人脸识别的角度对这个结论做了解释：假如在embedding层之前，特征的输出是7×7×512，这时7×7的范围内，角点和中心点对人脸特征的贡献是不同的，中心点对人脸特征的贡献更大。但如果使用global average pooling，则相当于把7×7个点的每个点的贡献视为均等的，这就降低了模型的特征提取能力。 如果不采用global average pooling，也可以采用全连接层，但这样会大大增加计算量，并不适合用于移动端设备。 本文对这个问题的改进方法是在embedding层之前增加depth-wise conv层，假如特征的输出是7×7×512，那么增加的depth-wise conv层的核就是7×7×512，增加的层和特征输出卷积计算就会得到1×1×512的层，可以把这个层直接做为embedding层，但在本文的标准MobileFaceNets模型中，其后增加了一个1×1的卷积层。 本文用实验结果证明，在MobileNetV2网络上，仅改变这一点，就能得到比MobileNetV2效果好的模型。后面本文在MobileNetV2的基础上设计了效果更好的MobileFaceNets系列网络。 网络模型本文的网络模型是基于MobileNetV2改进的，基本和结构和MobileNetV2几乎一样： 实验效果ArcFace loss MS-Celeb-1M database [5] with 3.8M images from 85K subjects： MobileFaceNet， LFW acc 99.55%，AgeDB Acc. 96.07%，Megaface acc 90.39, val(1e-6) 92.59 在所有的适用于移动端的网络中，效果是最好的，模型也比MobileNetV2 MobileNetV1要小。 但不考虑移动端计算能力因素，目前效果最好的人脸识别网络是iBUG_DeepInsight (ArcFace [5] LResNet100EIR)：LFW acc 99.83%， AgeDB Acc 98.08%， Megaface acc 98.06, val(1e-6) 98.48 关于MobileNetV2mobilenetV2在延续mobilenetv1的depth-wise卷积的基础上，使用了resnet的shortcut连接，但并不是直接在depth-wise卷积块的前后加上shortcut连接，mobilenetV2的bottleneck块的主要思想如下： 因为普通residual block一般是先用1×1卷积压缩通道数，然后再做卷积，再用1×1卷积扩展通道数。如果在depth-wise卷积之前像这样先压缩通道，那么效果会很差，因为depth-wise卷积依赖于较多的通道数。所以mobilenetV2使用了和普通residual block相反的策略，先扩展通道数，再做depth-wise卷积，然后压缩通道数，并称之为Inverted residuals。 bottleneck块最后，并不使用Relu来做非线性操作，而是直接输出Linear bottlenecks。这是因为在做了扩展-depth-wise卷积-压缩操作后，特征已经被压缩，这时再做Relu会破坏特征，实验证明，不做Relu能提升效果]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>人脸识别</tag>
      </tags>
  </entry>
</search>
