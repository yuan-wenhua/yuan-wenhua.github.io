<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode 刷题记录-56.Merge Intervals]]></title>
    <url>%2F2019%2F02%2F22%2Fleetcode%20%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-56.Merge%20Intervals%2F</url>
    <content type="text"><![CDATA[题目Given a collection of intervals, merge all overlapping intervals. Example 1: 123Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: 123Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. 说明给定一组表示区间的列表，把其中所有有重叠的区间合并，输出新的一组区间列表 分析解题思路首先对输入的列表按照start值由小到大排序。然后取已排序列表的第一个区间的end和下一个区间的start对比，如果有重叠，则更新区间的end为这两个区间的end中较大的一个；如果没有重叠，则把更新后的区间增加到返回列表中。然后继续与已排序列表中的下一个对比，直到列表的末尾。 复杂度分析排序的时间复杂度为O(nlogn), 列表逐元素对比的时间复杂度为O(n)，所以总体的时间复杂度为O(nlogn)。 代码123456789101112131415161718192021222324252627282930/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if(intervals.size() &lt;= 1) return intervals; intervals.sort((i1, i2) -&gt; Integer.compare(i1.start, i2.start)); List&lt;Interval&gt; result = new LinkedList&lt;Interval&gt;(); int start = intervals.get(0).start; int end = intervals.get(0).end; for(Interval interval : intervals)&#123; if(interval.start &lt;= end)&#123; end = Math.max(interval.end, end); &#125;else&#123; result.add(new Interval(start, end)); start = interval.start; end = interval.end; &#125; &#125; result.add(new Interval(start, end)); return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列和管道]]></title>
    <url>%2F2019%2F02%2F21%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[linux系统中多进程通信的方法有管道、消息队列、信号量、共享内存、套接字等。 本文记录下最近用到的消息队列和管道 消息队列定义消息队列消息队列是从一个进程发送数据块到另一个进程的一种方法。数据块存放在一个消息结构体中，消息结构体需要自定义。 消息队列的使用使用消息队列主要使用如下三个函数： msgget1int msgget(key_t, key, int msgflg); 用于根据key获取一个消息队列的id，msgflg表示消息队列的访问权限，和文件的访问权限一致。如果消息队列不存在，且msgflg和IPC_CREATE做或操作，那么会创建一个新的消息队列并返回这个新消息队列的id。所以msgget也用于创建消息队列。 msgsnd1int msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg); 用于发送一条消息到id为msgid的消息队列中去，各参数的说明如下： 其中msgid是由msgget创建的消息队列id。 msg_ptr指针指向消息结构体，这个消息结构体需要自己定义且需要遵循一定的规则： 结构体的第一个元素必须是个长整型变量，用于指示消息类型，消息类型后面会详细解释 结构体的其他元素可以自定义，用于传输自己需要的数据。传输数据的大小是有限制的，在Linunx中，一条消息的最大长度为MSGMAX 如： 12345struct msg_st&#123; long int msg_type; char msg_text[32];&#125;; msg_sz是消息结构体中的消息数据的长度 msgflg用于控制当消息队列满了或超过系统限制时发生的事情，通常设为0 msgrcv1int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg); msgrcv用于接收消息队列，它的参数大多和msgsnd一致，只是多了一个msgtype参数，这个参数和消息结构体中的消息类型配合使用 msgctl1int msgctl(int msgid, int command, struct msgid_ds *buf); 用于获取和设置消息队列的属性 command命令有： IPC_STAT ： 获取消息队列的数据到buf中 IPC_SET ：为消息队列设置属性，属性事先存在buf中。可设置的属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes IPC_RMID：删除消息队列 消息类型消息结构中的消息类型表示要发送的消息的类型，消息类型的作用与接收消息的进程的msgrcv的参数有关： 如果msgrcv参数中的msgtype设置为0，则会接收对应消息队列中的第一条消息，无论这条消息的消息类型是什么。 如果msgrcv参数中的msgtype设置为大于0，则只能接收对应消息队列中消息类型和msgrcv参数中的msgtype一致的消息。 消息队列示例123456789101112131415161718192021222324252627282930313233343536373839404142//发送消息队列int send_message(int msg_key)&#123; struct msg_st msgdata; int msgid = -1; msgdata.msg_type = 1; sprintf(msgdata.msg_text, "%d", frame_second); msgid = msgget((key_t)msg_key, 0666 | IPC_CREAT); if(msgid == -1) &#123; return -1; &#125; if(msgsnd(msgid, (void*)&amp;msgdata, sizeof(msgdata.msg_text), 0) == -1) &#123; return -1; &#125; return 0;&#125;//接收消息队列并删除之int receive_msg( int msg_key)&#123; int msgid = msgget((key_t)msg_key, 0666 | IPC_CREAT); long int msgtype = 0; struct msg_st msgdata; if(msgid == -1) &#123; return -1; &#125; if(msgrcv(msgid, (void*)&amp;msgdata, sizeof(msgdata.msg_text), msgtype, 0) == -1) &#123; return -1; &#125; if(msgctl(msgid, IPC_RMID, 0) == -1) &#123; return -1; &#125; return 0;&#125; 管道定义管道管道，顾名思义，是数据从一端输入另一端输出的通信机制，管道里的数据是流式的，不可反复读取。 它仅适用于有公共祖先的两个进程，具有公共祖先的两个进程可以是父子进程，也可以是由同一父进程fork出的兄弟进程。 普通的管道是半双工的，即只能一端输入，另一端输出，数据是单向流动的。另外有“流管道”是支持全双工的，本文仅介绍半双工的普通管道。 生成管道管道的生成方式很简单，只需要调用pipe函数，pipe函数的原型： 12#include &lt;unistd.h&gt;int pipe(int pipefd[2]); //成功返回0，失败返回-1并设置errno pipe函数的参数是长度为2的int数组，调用pipe函数成功后，数组内存储着管道的两个文件描述符，其中pidfd[0]为读文件描述符，pipefd[1]为写文件描述符。这两个文件描述符都是已经打开的，不需要对其调用open函数。但需要在使用的时候用close函数关闭掉。 pipe的创建是在主进程内进行的，假设要创建一个父子进程间的管道，当主进程使用fork函数创建出子进程时，在主进程和子进程里各有一对pipeid，都可以进行读写。这时要根据实际需要决定是在主进程内读子进程内写还是与之相反。无论哪种情况，都要在两个进程内把用不到的文件描述符close，保留需要的文件描述符。 管道的几种状态写管道时： 如果管道读端已经关闭 进程异常终止，或者如果程序中捕获SIGPIPE信号，这样进程就不会终止了 如果管道读端没有关闭 如果管道已经写满，阻塞，等待管道有空 如果管道没有写满，则正常写入 读管道时： 如果管道写端已经关闭 read返回0，类似读文件读到文件末尾 如果管道写端没有关闭 如果管道内有数据，read返回读到的字节数 如果管道内没有数据，阻塞直到管道内有数据 管道示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; int pipefd[2]; int res = pipe(pipefd); int pid; if(res == -1)&#123; printf("create pipe failed!"); &#125; pid = fork(); switch (pid) &#123; case -1: /* failure */ if(pipefd[0] != -1)&#123; close(pipefd[0]); &#125; if(pipefd[1] != -1)&#123; close(pipefd[1]); &#125; printf("fork failed"); break; case 0: /* child */ if (pipefd[0] != -1) &#123; close(pipefd[0]); &#125; dup2(pipefd[0], STDOUT_FILENO); //将ls的结果写入管道中 execlp("ls", "ls", "-lrt", NULL); //ls输出结果默认对应屏幕 default: /* parent */ if (pipefd[1] != -1) &#123; close(pipefd[1]); &#125; dup2(pipefd[1], STDIN_FILENO); //让wc从管道中读取数据 execlp("wc", "wc", "-l", NULL); //wc命令默认从标准读入取数据 &#125; return 0;&#125; 消息队列和管道的对比 消息队列可以用于不具有亲缘关系的进程，而管道只能用于具有亲缘关系的进程 二者都是用发送和接收的方式传输数据]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>多进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MobileFaceNets论文阅读笔记]]></title>
    <url>%2F2018%2F05%2F02%2FMobileFaceNets%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[论文链接：MobileFaceNets: Efficient CNNs for Accurate Real-Time Face Verification on Mobile Devices 核心改进点用 MobileNetV1, ShuffleNet, MobileNetV2等网络做人脸识别时，在embedding层之前往往采用global average pooling得到特征，但其他论文已经提出使用global average pooling后的CNN效果会比不使用global average pooling差，本文从人脸识别的角度对这个结论做了解释：假如在embedding层之前，特征的输出是7×7×512，这时7×7的范围内，角点和中心点对人脸特征的贡献是不同的，中心点对人脸特征的贡献更大。但如果使用global average pooling，则相当于把7×7个点的每个点的贡献视为均等的，这就降低了模型的特征提取能力。 如果不采用global average pooling，也可以采用全连接层，但这样会大大增加计算量，并不适合用于移动端设备。 本文对这个问题的改进方法是在embedding层之前增加depth-wise conv层，假如特征的输出是7×7×512，那么增加的depth-wise conv层的核就是7×7×512，增加的层和特征输出卷积计算就会得到1×1×512的层，可以把这个层直接做为embedding层，但在本文的标准MobileFaceNets模型中，其后增加了一个1×1的卷积层。 本文用实验结果证明，在MobileNetV2网络上，仅改变这一点，就能得到比MobileNetV2效果好的模型。后面本文在MobileNetV2的基础上设计了效果更好的MobileFaceNets系列网络。 网络模型本文的网络模型是基于MobileNetV2改进的，基本和结构和MobileNetV2几乎一样： 实验效果ArcFace loss MS-Celeb-1M database [5] with 3.8M images from 85K subjects： MobileFaceNet， LFW acc 99.55%，AgeDB Acc. 96.07%，Megaface acc 90.39, val(1e-6) 92.59 在所有的适用于移动端的网络中，效果是最好的，模型也比MobileNetV2 MobileNetV1要小。 但不考虑移动端计算能力因素，目前效果最好的人脸识别网络是iBUG_DeepInsight (ArcFace [5] LResNet100EIR)：LFW acc 99.83%， AgeDB Acc 98.08%， Megaface acc 98.06, val(1e-6) 98.48 关于MobileNetV2mobilenetV2在延续mobilenetv1的depth-wise卷积的基础上，使用了resnet的shortcut连接，但并不是直接在depth-wise卷积块的前后加上shortcut连接，mobilenetV2的bottleneck块的主要思想如下： 因为普通residual block一般是先用1×1卷积压缩通道数，然后再做卷积，再用1×1卷积扩展通道数。如果在depth-wise卷积之前像这样先压缩通道，那么效果会很差，因为depth-wise卷积依赖于较多的通道数。所以mobilenetV2使用了和普通residual block相反的策略，先扩展通道数，再做depth-wise卷积，然后压缩通道数，并称之为Inverted residuals。 bottleneck块最后，并不使用Relu来做非线性操作，而是直接输出Linear bottlenecks。这是因为在做了扩展-depth-wise卷积-压缩操作后，特征已经被压缩，这时再做Relu会破坏特征，实验证明，不做Relu能提升效果]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>人脸识别</tag>
      </tags>
  </entry>
</search>
